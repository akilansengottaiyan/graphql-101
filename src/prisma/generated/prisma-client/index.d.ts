// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  app: (where?: AppWhereInput) => Promise<boolean>;
  flow: (where?: FlowWhereInput) => Promise<boolean>;
  step: (where?: StepWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  app: (where: AppWhereUniqueInput) => AppNullablePromise;
  apps: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<App>;
  appsConnection: (args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppConnectionPromise;
  flow: (where: FlowWhereUniqueInput) => FlowNullablePromise;
  flows: (args?: {
    where?: FlowWhereInput;
    orderBy?: FlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Flow>;
  flowsConnection: (args?: {
    where?: FlowWhereInput;
    orderBy?: FlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FlowConnectionPromise;
  step: (where: StepWhereUniqueInput) => StepNullablePromise;
  steps: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Step>;
  stepsConnection: (args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StepConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApp: (data: AppCreateInput) => AppPromise;
  updateApp: (args: {
    data: AppUpdateInput;
    where: AppWhereUniqueInput;
  }) => AppPromise;
  updateManyApps: (args: {
    data: AppUpdateManyMutationInput;
    where?: AppWhereInput;
  }) => BatchPayloadPromise;
  upsertApp: (args: {
    where: AppWhereUniqueInput;
    create: AppCreateInput;
    update: AppUpdateInput;
  }) => AppPromise;
  deleteApp: (where: AppWhereUniqueInput) => AppPromise;
  deleteManyApps: (where?: AppWhereInput) => BatchPayloadPromise;
  createFlow: (data: FlowCreateInput) => FlowPromise;
  updateFlow: (args: {
    data: FlowUpdateInput;
    where: FlowWhereUniqueInput;
  }) => FlowPromise;
  updateManyFlows: (args: {
    data: FlowUpdateManyMutationInput;
    where?: FlowWhereInput;
  }) => BatchPayloadPromise;
  upsertFlow: (args: {
    where: FlowWhereUniqueInput;
    create: FlowCreateInput;
    update: FlowUpdateInput;
  }) => FlowPromise;
  deleteFlow: (where: FlowWhereUniqueInput) => FlowPromise;
  deleteManyFlows: (where?: FlowWhereInput) => BatchPayloadPromise;
  createStep: (data: StepCreateInput) => StepPromise;
  updateStep: (args: {
    data: StepUpdateInput;
    where: StepWhereUniqueInput;
  }) => StepPromise;
  updateManySteps: (args: {
    data: StepUpdateManyMutationInput;
    where?: StepWhereInput;
  }) => BatchPayloadPromise;
  upsertStep: (args: {
    where: StepWhereUniqueInput;
    create: StepCreateInput;
    update: StepUpdateInput;
  }) => StepPromise;
  deleteStep: (where: StepWhereUniqueInput) => StepPromise;
  deleteManySteps: (where?: StepWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  app: (
    where?: AppSubscriptionWhereInput
  ) => AppSubscriptionPayloadSubscription;
  flow: (
    where?: FlowSubscriptionWhereInput
  ) => FlowSubscriptionPayloadSubscription;
  step: (
    where?: StepSubscriptionWhereInput
  ) => StepSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FlowType = "MODAL" | "HOTSPOT";

export type AppOrderByInput = "id_ASC" | "id_DESC" | "url_ASC" | "url_DESC";

export type FlowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "flowType_ASC"
  | "flowType_DESC";

export type StepOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC"
  | "text_ASC"
  | "text_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface StepUpdateWithoutAssociatedWithDataInput {
  order?: Maybe<Int>;
  text?: Maybe<String>;
}

export type AppWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StepUpdateManyDataInput {
  order?: Maybe<Int>;
  text?: Maybe<String>;
}

export interface FlowWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  flowType?: Maybe<FlowType>;
  flowType_not?: Maybe<FlowType>;
  flowType_in?: Maybe<FlowType[] | FlowType>;
  flowType_not_in?: Maybe<FlowType[] | FlowType>;
  associatedWith?: Maybe<AppWhereInput>;
  steps_every?: Maybe<StepWhereInput>;
  steps_some?: Maybe<StepWhereInput>;
  steps_none?: Maybe<StepWhereInput>;
  AND?: Maybe<FlowWhereInput[] | FlowWhereInput>;
  OR?: Maybe<FlowWhereInput[] | FlowWhereInput>;
  NOT?: Maybe<FlowWhereInput[] | FlowWhereInput>;
}

export interface FlowUpsertWithWhereUniqueWithoutAssociatedWithInput {
  where: FlowWhereUniqueInput;
  update: FlowUpdateWithoutAssociatedWithDataInput;
  create: FlowCreateWithoutAssociatedWithInput;
}

export interface StepWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  associatedWith?: Maybe<FlowWhereInput>;
  AND?: Maybe<StepWhereInput[] | StepWhereInput>;
  OR?: Maybe<StepWhereInput[] | StepWhereInput>;
  NOT?: Maybe<StepWhereInput[] | StepWhereInput>;
}

export interface FlowScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  flowType?: Maybe<FlowType>;
  flowType_not?: Maybe<FlowType>;
  flowType_in?: Maybe<FlowType[] | FlowType>;
  flowType_not_in?: Maybe<FlowType[] | FlowType>;
  AND?: Maybe<FlowScalarWhereInput[] | FlowScalarWhereInput>;
  OR?: Maybe<FlowScalarWhereInput[] | FlowScalarWhereInput>;
  NOT?: Maybe<FlowScalarWhereInput[] | FlowScalarWhereInput>;
}

export interface AppWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdBy?: Maybe<UserWhereInput>;
  flows_every?: Maybe<FlowWhereInput>;
  flows_some?: Maybe<FlowWhereInput>;
  flows_none?: Maybe<FlowWhereInput>;
  AND?: Maybe<AppWhereInput[] | AppWhereInput>;
  OR?: Maybe<AppWhereInput[] | AppWhereInput>;
  NOT?: Maybe<AppWhereInput[] | AppWhereInput>;
}

export interface UserUpdateOneRequiredWithoutAppsInput {
  create?: Maybe<UserCreateWithoutAppsInput>;
  update?: Maybe<UserUpdateWithoutAppsDataInput>;
  upsert?: Maybe<UserUpsertWithoutAppsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FlowCreateOneWithoutStepsInput {
  create?: Maybe<FlowCreateWithoutStepsInput>;
  connect?: Maybe<FlowWhereUniqueInput>;
}

export interface UserUpdateWithoutAppsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface FlowUpdateManyWithWhereNestedInput {
  where: FlowScalarWhereInput;
  data: FlowUpdateManyDataInput;
}

export interface UserUpsertWithoutAppsInput {
  update: UserUpdateWithoutAppsDataInput;
  create: UserCreateWithoutAppsInput;
}

export interface StepSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StepWhereInput>;
  AND?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
  OR?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
  NOT?: Maybe<StepSubscriptionWhereInput[] | StepSubscriptionWhereInput>;
}

export interface FlowUpdateManyWithoutAssociatedWithInput {
  create?: Maybe<
    | FlowCreateWithoutAssociatedWithInput[]
    | FlowCreateWithoutAssociatedWithInput
  >;
  delete?: Maybe<FlowWhereUniqueInput[] | FlowWhereUniqueInput>;
  connect?: Maybe<FlowWhereUniqueInput[] | FlowWhereUniqueInput>;
  set?: Maybe<FlowWhereUniqueInput[] | FlowWhereUniqueInput>;
  disconnect?: Maybe<FlowWhereUniqueInput[] | FlowWhereUniqueInput>;
  update?: Maybe<
    | FlowUpdateWithWhereUniqueWithoutAssociatedWithInput[]
    | FlowUpdateWithWhereUniqueWithoutAssociatedWithInput
  >;
  upsert?: Maybe<
    | FlowUpsertWithWhereUniqueWithoutAssociatedWithInput[]
    | FlowUpsertWithWhereUniqueWithoutAssociatedWithInput
  >;
  deleteMany?: Maybe<FlowScalarWhereInput[] | FlowScalarWhereInput>;
  updateMany?: Maybe<
    FlowUpdateManyWithWhereNestedInput[] | FlowUpdateManyWithWhereNestedInput
  >;
}

export interface AppSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppWhereInput>;
  AND?: Maybe<AppSubscriptionWhereInput[] | AppSubscriptionWhereInput>;
  OR?: Maybe<AppSubscriptionWhereInput[] | AppSubscriptionWhereInput>;
  NOT?: Maybe<AppSubscriptionWhereInput[] | AppSubscriptionWhereInput>;
}

export interface FlowUpdateWithWhereUniqueWithoutAssociatedWithInput {
  where: FlowWhereUniqueInput;
  data: FlowUpdateWithoutAssociatedWithDataInput;
}

export interface AppUpdateManyDataInput {
  url?: Maybe<String>;
}

export interface FlowUpdateWithoutAssociatedWithDataInput {
  title?: Maybe<String>;
  flowType?: Maybe<FlowType>;
  steps?: Maybe<StepUpdateManyWithoutAssociatedWithInput>;
}

export interface AppUpdateManyWithWhereNestedInput {
  where: AppScalarWhereInput;
  data: AppUpdateManyDataInput;
}

export interface StepUpdateManyWithoutAssociatedWithInput {
  create?: Maybe<
    | StepCreateWithoutAssociatedWithInput[]
    | StepCreateWithoutAssociatedWithInput
  >;
  delete?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  set?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  disconnect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
  update?: Maybe<
    | StepUpdateWithWhereUniqueWithoutAssociatedWithInput[]
    | StepUpdateWithWhereUniqueWithoutAssociatedWithInput
  >;
  upsert?: Maybe<
    | StepUpsertWithWhereUniqueWithoutAssociatedWithInput[]
    | StepUpsertWithWhereUniqueWithoutAssociatedWithInput
  >;
  deleteMany?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  updateMany?: Maybe<
    StepUpdateManyWithWhereNestedInput[] | StepUpdateManyWithWhereNestedInput
  >;
}

export interface AppUpsertWithWhereUniqueWithoutCreatedByInput {
  where: AppWhereUniqueInput;
  update: AppUpdateWithoutCreatedByDataInput;
  create: AppCreateWithoutCreatedByInput;
}

export interface StepUpdateWithWhereUniqueWithoutAssociatedWithInput {
  where: StepWhereUniqueInput;
  data: StepUpdateWithoutAssociatedWithDataInput;
}

export interface AppUpdateWithoutCreatedByDataInput {
  url?: Maybe<String>;
  flows?: Maybe<FlowUpdateManyWithoutAssociatedWithInput>;
}

export interface StepUpdateManyMutationInput {
  order?: Maybe<Int>;
  text?: Maybe<String>;
}

export interface AppUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    AppCreateWithoutCreatedByInput[] | AppCreateWithoutCreatedByInput
  >;
  delete?: Maybe<AppWhereUniqueInput[] | AppWhereUniqueInput>;
  connect?: Maybe<AppWhereUniqueInput[] | AppWhereUniqueInput>;
  set?: Maybe<AppWhereUniqueInput[] | AppWhereUniqueInput>;
  disconnect?: Maybe<AppWhereUniqueInput[] | AppWhereUniqueInput>;
  update?: Maybe<
    | AppUpdateWithWhereUniqueWithoutCreatedByInput[]
    | AppUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | AppUpsertWithWhereUniqueWithoutCreatedByInput[]
    | AppUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<AppScalarWhereInput[] | AppScalarWhereInput>;
  updateMany?: Maybe<
    AppUpdateManyWithWhereNestedInput[] | AppUpdateManyWithWhereNestedInput
  >;
}

export interface StepUpsertWithWhereUniqueWithoutAssociatedWithInput {
  where: StepWhereUniqueInput;
  update: StepUpdateWithoutAssociatedWithDataInput;
  create: StepCreateWithoutAssociatedWithInput;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  apps?: Maybe<AppUpdateManyWithoutCreatedByInput>;
}

export interface StepScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  OR?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
  NOT?: Maybe<StepScalarWhereInput[] | StepScalarWhereInput>;
}

export interface AppCreateManyWithoutCreatedByInput {
  create?: Maybe<
    AppCreateWithoutCreatedByInput[] | AppCreateWithoutCreatedByInput
  >;
  connect?: Maybe<AppWhereUniqueInput[] | AppWhereUniqueInput>;
}

export interface StepUpdateManyWithWhereNestedInput {
  where: StepScalarWhereInput;
  data: StepUpdateManyDataInput;
}

export interface UserCreateOneWithoutAppsInput {
  create?: Maybe<UserCreateWithoutAppsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  apps_every?: Maybe<AppWhereInput>;
  apps_some?: Maybe<AppWhereInput>;
  apps_none?: Maybe<AppWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface FlowCreateManyWithoutAssociatedWithInput {
  create?: Maybe<
    | FlowCreateWithoutAssociatedWithInput[]
    | FlowCreateWithoutAssociatedWithInput
  >;
  connect?: Maybe<FlowWhereUniqueInput[] | FlowWhereUniqueInput>;
}

export interface FlowUpsertWithoutStepsInput {
  update: FlowUpdateWithoutStepsDataInput;
  create: FlowCreateWithoutStepsInput;
}

export interface StepCreateManyWithoutAssociatedWithInput {
  create?: Maybe<
    | StepCreateWithoutAssociatedWithInput[]
    | StepCreateWithoutAssociatedWithInput
  >;
  connect?: Maybe<StepWhereUniqueInput[] | StepWhereUniqueInput>;
}

export interface FlowUpdateWithoutStepsDataInput {
  title?: Maybe<String>;
  flowType?: Maybe<FlowType>;
  associatedWith?: Maybe<AppUpdateOneRequiredWithoutFlowsInput>;
}

export interface AppUpdateInput {
  url?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutAppsInput>;
  flows?: Maybe<FlowUpdateManyWithoutAssociatedWithInput>;
}

export interface FlowUpdateOneRequiredWithoutStepsInput {
  create?: Maybe<FlowCreateWithoutStepsInput>;
  update?: Maybe<FlowUpdateWithoutStepsDataInput>;
  upsert?: Maybe<FlowUpsertWithoutStepsInput>;
  connect?: Maybe<FlowWhereUniqueInput>;
}

export interface FlowSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FlowWhereInput>;
  AND?: Maybe<FlowSubscriptionWhereInput[] | FlowSubscriptionWhereInput>;
  OR?: Maybe<FlowSubscriptionWhereInput[] | FlowSubscriptionWhereInput>;
  NOT?: Maybe<FlowSubscriptionWhereInput[] | FlowSubscriptionWhereInput>;
}

export interface FlowUpdateManyDataInput {
  title?: Maybe<String>;
  flowType?: Maybe<FlowType>;
}

export type FlowWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export interface AppUpdateManyMutationInput {
  url?: Maybe<String>;
}

export type StepWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StepUpdateInput {
  order?: Maybe<Int>;
  text?: Maybe<String>;
  associatedWith?: Maybe<FlowUpdateOneRequiredWithoutStepsInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface FlowCreateWithoutStepsInput {
  id?: Maybe<ID_Input>;
  title: String;
  flowType: FlowType;
  associatedWith: AppCreateOneWithoutFlowsInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName?: Maybe<String>;
  email: String;
  password: String;
  apps?: Maybe<AppCreateManyWithoutCreatedByInput>;
}

export interface FlowCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  flowType: FlowType;
  associatedWith: AppCreateOneWithoutFlowsInput;
  steps?: Maybe<StepCreateManyWithoutAssociatedWithInput>;
}

export interface UserCreateWithoutAppsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName?: Maybe<String>;
  email: String;
  password: String;
}

export interface AppCreateOneWithoutFlowsInput {
  create?: Maybe<AppCreateWithoutFlowsInput>;
  connect?: Maybe<AppWhereUniqueInput>;
}

export interface StepCreateWithoutAssociatedWithInput {
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  text: String;
}

export interface AppCreateWithoutFlowsInput {
  id?: Maybe<ID_Input>;
  url: String;
  createdBy: UserCreateOneWithoutAppsInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface FlowUpdateInput {
  title?: Maybe<String>;
  flowType?: Maybe<FlowType>;
  associatedWith?: Maybe<AppUpdateOneRequiredWithoutFlowsInput>;
  steps?: Maybe<StepUpdateManyWithoutAssociatedWithInput>;
}

export interface AppUpdateWithWhereUniqueWithoutCreatedByInput {
  where: AppWhereUniqueInput;
  data: AppUpdateWithoutCreatedByDataInput;
}

export interface AppUpdateOneRequiredWithoutFlowsInput {
  create?: Maybe<AppCreateWithoutFlowsInput>;
  update?: Maybe<AppUpdateWithoutFlowsDataInput>;
  upsert?: Maybe<AppUpsertWithoutFlowsInput>;
  connect?: Maybe<AppWhereUniqueInput>;
}

export interface AppCreateInput {
  id?: Maybe<ID_Input>;
  url: String;
  createdBy: UserCreateOneWithoutAppsInput;
  flows?: Maybe<FlowCreateManyWithoutAssociatedWithInput>;
}

export interface StepCreateInput {
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  text: String;
  associatedWith: FlowCreateOneWithoutStepsInput;
}

export interface FlowUpdateManyMutationInput {
  title?: Maybe<String>;
  flowType?: Maybe<FlowType>;
}

export interface AppUpsertWithoutFlowsInput {
  update: AppUpdateWithoutFlowsDataInput;
  create: AppCreateWithoutFlowsInput;
}

export interface AppUpdateWithoutFlowsDataInput {
  url?: Maybe<String>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutAppsInput>;
}

export interface FlowCreateWithoutAssociatedWithInput {
  id?: Maybe<ID_Input>;
  title: String;
  flowType: FlowType;
  steps?: Maybe<StepCreateManyWithoutAssociatedWithInput>;
}

export interface AppCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  url: String;
  flows?: Maybe<FlowCreateManyWithoutAssociatedWithInput>;
}

export interface AppScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<AppScalarWhereInput[] | AppScalarWhereInput>;
  OR?: Maybe<AppScalarWhereInput[] | AppScalarWhereInput>;
  NOT?: Maybe<AppScalarWhereInput[] | AppScalarWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName?: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface FlowConnection {
  pageInfo: PageInfo;
  edges: FlowEdge[];
}

export interface FlowConnectionPromise
  extends Promise<FlowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FlowEdge>>() => T;
  aggregate: <T = AggregateFlowPromise>() => T;
}

export interface FlowConnectionSubscription
  extends Promise<AsyncIterator<FlowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FlowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFlowSubscription>() => T;
}

export interface Flow {
  id: ID_Output;
  title: String;
  flowType: FlowType;
}

export interface FlowPromise extends Promise<Flow>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  flowType: () => Promise<FlowType>;
  associatedWith: <T = AppPromise>() => T;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FlowSubscription
  extends Promise<AsyncIterator<Flow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  flowType: () => Promise<AsyncIterator<FlowType>>;
  associatedWith: <T = AppSubscription>() => T;
  steps: <T = Promise<AsyncIterator<StepSubscription>>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FlowNullablePromise
  extends Promise<Flow | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  flowType: () => Promise<FlowType>;
  associatedWith: <T = AppPromise>() => T;
  steps: <T = FragmentableArray<Step>>(args?: {
    where?: StepWhereInput;
    orderBy?: StepOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateApp {
  count: Int;
}

export interface AggregateAppPromise
  extends Promise<AggregateApp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppSubscription
  extends Promise<AsyncIterator<AggregateApp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName?: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  apps: <T = FragmentableArray<App>>(args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  apps: <T = Promise<AsyncIterator<AppSubscription>>>(args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  apps: <T = FragmentableArray<App>>(args?: {
    where?: AppWhereInput;
    orderBy?: AppOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AppConnection {
  pageInfo: PageInfo;
  edges: AppEdge[];
}

export interface AppConnectionPromise
  extends Promise<AppConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppEdge>>() => T;
  aggregate: <T = AggregateAppPromise>() => T;
}

export interface AppConnectionSubscription
  extends Promise<AsyncIterator<AppConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppSubscription>() => T;
}

export interface Step {
  id: ID_Output;
  order?: Int;
  text: String;
}

export interface StepPromise extends Promise<Step>, Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  text: () => Promise<String>;
  associatedWith: <T = FlowPromise>() => T;
}

export interface StepSubscription
  extends Promise<AsyncIterator<Step>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
  associatedWith: <T = FlowSubscription>() => T;
}

export interface StepNullablePromise
  extends Promise<Step | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  text: () => Promise<String>;
  associatedWith: <T = FlowPromise>() => T;
}

export interface AppEdge {
  node: App;
  cursor: String;
}

export interface AppEdgePromise extends Promise<AppEdge>, Fragmentable {
  node: <T = AppPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppEdgeSubscription
  extends Promise<AsyncIterator<AppEdge>>,
    Fragmentable {
  node: <T = AppSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StepPreviousValues {
  id: ID_Output;
  order?: Int;
  text: String;
}

export interface StepPreviousValuesPromise
  extends Promise<StepPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  text: () => Promise<String>;
}

export interface StepPreviousValuesSubscription
  extends Promise<AsyncIterator<StepPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StepSubscriptionPayload {
  mutation: MutationType;
  node: Step;
  updatedFields: String[];
  previousValues: StepPreviousValues;
}

export interface StepSubscriptionPayloadPromise
  extends Promise<StepSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StepPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StepPreviousValuesPromise>() => T;
}

export interface StepSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StepSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StepSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StepPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface App {
  id: ID_Output;
  url: String;
}

export interface AppPromise extends Promise<App>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  flows: <T = FragmentableArray<Flow>>(args?: {
    where?: FlowWhereInput;
    orderBy?: FlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AppSubscription
  extends Promise<AsyncIterator<App>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  flows: <T = Promise<AsyncIterator<FlowSubscription>>>(args?: {
    where?: FlowWhereInput;
    orderBy?: FlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AppNullablePromise extends Promise<App | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  flows: <T = FragmentableArray<Flow>>(args?: {
    where?: FlowWhereInput;
    orderBy?: FlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StepEdge {
  node: Step;
  cursor: String;
}

export interface StepEdgePromise extends Promise<StepEdge>, Fragmentable {
  node: <T = StepPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StepEdgeSubscription
  extends Promise<AsyncIterator<StepEdge>>,
    Fragmentable {
  node: <T = StepSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppSubscriptionPayload {
  mutation: MutationType;
  node: App;
  updatedFields: String[];
  previousValues: AppPreviousValues;
}

export interface AppSubscriptionPayloadPromise
  extends Promise<AppSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppPreviousValuesPromise>() => T;
}

export interface AppSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppPreviousValuesSubscription>() => T;
}

export interface AggregateFlow {
  count: Int;
}

export interface AggregateFlowPromise
  extends Promise<AggregateFlow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFlowSubscription
  extends Promise<AsyncIterator<AggregateFlow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FlowPreviousValues {
  id: ID_Output;
  title: String;
  flowType: FlowType;
}

export interface FlowPreviousValuesPromise
  extends Promise<FlowPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  flowType: () => Promise<FlowType>;
}

export interface FlowPreviousValuesSubscription
  extends Promise<AsyncIterator<FlowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  flowType: () => Promise<AsyncIterator<FlowType>>;
}

export interface FlowSubscriptionPayload {
  mutation: MutationType;
  node: Flow;
  updatedFields: String[];
  previousValues: FlowPreviousValues;
}

export interface FlowSubscriptionPayloadPromise
  extends Promise<FlowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FlowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FlowPreviousValuesPromise>() => T;
}

export interface FlowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FlowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FlowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FlowPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AppPreviousValues {
  id: ID_Output;
  url: String;
}

export interface AppPreviousValuesPromise
  extends Promise<AppPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
}

export interface AppPreviousValuesSubscription
  extends Promise<AsyncIterator<AppPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface FlowEdge {
  node: Flow;
  cursor: String;
}

export interface FlowEdgePromise extends Promise<FlowEdge>, Fragmentable {
  node: <T = FlowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FlowEdgeSubscription
  extends Promise<AsyncIterator<FlowEdge>>,
    Fragmentable {
  node: <T = FlowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StepConnection {
  pageInfo: PageInfo;
  edges: StepEdge[];
}

export interface StepConnectionPromise
  extends Promise<StepConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StepEdge>>() => T;
  aggregate: <T = AggregateStepPromise>() => T;
}

export interface StepConnectionSubscription
  extends Promise<AsyncIterator<StepConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StepEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStepSubscription>() => T;
}

export interface AggregateStep {
  count: Int;
}

export interface AggregateStepPromise
  extends Promise<AggregateStep>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStepSubscription
  extends Promise<AsyncIterator<AggregateStep>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "App",
    embedded: false
  },
  {
    name: "Flow",
    embedded: false
  },
  {
    name: "Step",
    embedded: false
  },
  {
    name: "FlowType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
